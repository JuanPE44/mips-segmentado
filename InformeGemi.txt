### **Informe de Trabajo Práctico: Implementación de un Procesador MIPS Segmentado**

**Materia:** [Nombre de la Materia/Cátedra]
**Fecha:** 12 de junio de 2025

**Integrantes:**

* **Lautaro Bettini re putini**
    * DNI: 46.555.072
    * *(Insertar foto aquí)*

* **Juan Peñalba**
    * DNI: [Completar DNI]
    * *(Insertar foto aquí)*

* **Oliver Papussio**
    * DNI: [Completar DNI]
    * *(Insertar foto aquí)*

---

### **1. Metodología y Enfoque del Trabajo**

#### **1.1. Cómo Encaramos el Trabajo**

En el comienzo del proyecto, teníamos la duda de plantear la segmentación del pipeline mediante registros dedicados o simplemente con señales y procesos. Nos terminamos decantando por la segunda opción, ya que nos pareció la manera más correcta de hacerlo en VHDL. Este enfoque nos permitió tener una mejor visualización del flujo de datos entre las etapas y poder trabajar de manera más efectiva y modular en el código.

#### **1.2. Herramientas Utilizadas**

Para poder ordenarnos y tratar de que todos pudieran trabajar en armonía, utilizamos herramientas de desarrollo colaborativo como **Visual Studio Live Share**. Esto nos permitió programar de forma simultánea sobre el mismo código, analizar los cambios en tiempo real y discutir las soluciones en conjunto, lo que agilizó enormemente el proceso de desarrollo y depuración.

---

### **2. Descripción de Cambios Realizados**

Partiendo del procesador uniciclo funcional, realizamos las siguientes modificaciones estructurales para implementar el pipeline de 3 etapas:

* **Cambio en el Flanco de la Memoria de Datos:** Modificamos la escritura en la memoria de datos para que se active con el flanco descendente del reloj (`falling_edge`) en lugar del ascendente. Este cambio estratégico se hizo para evitar posibles condiciones de carrera (*race conditions*). Al separar la escritura en memoria del flanco en el que se actualizan la mayoría de los registros del pipeline, garantizamos una mayor estabilidad y prevenimos que se lean datos mientras están siendo escritos en el mismo ciclo.

* **Creación de Señales de Segmentación:** Agregamos un nuevo conjunto de señales intermedias (ej: **if_idEx_DataIn**, **idEx_memWb_ALU_result**, etc.) destinadas a transportar los datos y las señales de control de una etapa a la siguiente.

* **Implementación de Procesos de Segmentación:** Desarrollamos dos procesos secuenciales clave, sensibles al reloj, que actúan como las barreras del pipeline:
    1.  **IF/ID+EX:** Captura la instrucción y el PC+4 de la etapa de búsqueda.
    2.  **ID+EX/MEM+WB:** Captura los resultados de la ALU, datos de registros y todas las señales de control generadas en la etapa de decodificación/ejecución.

* **Claridad del Código:** Modificamos los nombres de varias señales y variables para que siguieran una nomenclatura consistente y clara (ej: prefijos **if_idEx_** y **idEx_memWb_**), facilitando la lectura y depuración del diseño.

### **3. Justificación de los Cambios**

Estos cambios fueron necesarios para adaptar el flujo de datos a la naturaleza secuencial del pipeline.

* **Etapa ID+EX:** Ya no lee directamente la salida de la memoria de instrucciones. Ahora, todos sus datos de entrada provienen de las señales **if_idEx_***. Por ejemplo, la unidad de control decodifica la instrucción guardada en **if_idEx_DataIn**.

* **Etapa MEM+WB:** Opera exclusivamente con la información que le llega a través de las señales **idEx_memWb_***. La dirección de memoria (**D_Addr**) es ahora **idEx_memWb_ALU_result**, y las señales de lectura/escritura de memoria son **idEx_memWb_MemRead** y **idEx_memWb_MemWrite**.

* **Lógica del PC:** La lógica para decidir cuál es el siguiente PC se tuvo que adaptar. Ahora, la decisión depende de las señales de salto (**Jump**) y bifurcación (**Branch**, **ALU_zero**) que se generan en la etapa ID+EX.

### **4. Análisis de Decisiones Críticas de Diseño (Líneas Clave)**

Durante la implementación, nos encontramos con decisiones de diseño cruciales que afectaban directamente la correcta funcionalidad del procesador.

#### **4.1. Actualización del Program Counter**

Una de las decisiones más importantes fue cómo actualizar el PC en cada ciclo. La línea de código final fue:
`next_reg_pc <= pc_jump when (Jump = '1') else pc_branch when ((ALU_zero='1') and (Branch='1')) else pc_4;`

La alternativa incorrecta era usar **if_idEx_pc_4** en lugar de **pc_4**. La razón para usar **pc_4** es la siguiente:
* El PC se actualiza al comienzo del pipeline (etapa IF). Por lo tanto, debe usar valores generados en esa misma etapa. **pc_4** es el valor de PC+4 calculado en la etapa IF actual.
* La señal **if_idEx_pc_4**, en cambio, es el valor de PC+4 de una instrucción que *ya avanzó* a la siguiente etapa. Usarla para actualizar el PC actual introduciría un desfase de un ciclo, rompiendo la secuencia de ejecución y la lógica de saltos.

#### **4.2. Optimización de la Extensión de Signo**

La implementación inicial de la extensión de signo era:
`inm_extended(31 downto 16) <= x"FFFF" when (if_idEx_DataIn(15)='1') else x"0000";`

La mejoramos a una versión más genérica y eficiente:
`inm_extended(31 downto 16) <= (others => if_idEx_DataIn(15));`
Esta sintaxis le indica al sintetizador que copie el bit de signo (el bit 15) en todas las posiciones superiores, lo cual es más robusto y claro.

#### **4.3. Cálculo de la Dirección de Salto Incondicional (Jump)**
La dirección de salto se calcula tomando los 4 bits más significativos del PC actual y concatenándolos con los 26 bits de la dirección de la instrucción y dos ceros al final. La implementación correcta es:
`pc_jump <= (if_idEx_pc_4(31 downto 28) & if_idEx_DataIn(25 downto 0) & "00");`
Aquí se usan los bits directamente del campo de la instrucción (**if_idEx_DataIn**), ya que para una instrucción tipo J, este campo contiene la dirección de salto, a diferencia de una instrucción tipo I donde el inmediato es de 16 bits y requiere extensión de signo.

### **5. Resultados Obtenidos**

La implementación del pipeline de 3 etapas nos permitió alcanzar los siguientes objetivos clave:

* **Paralelismo real:** Logramos que el procesador trabaje con hasta tres instrucciones a la vez (una en cada etapa), lo cual era el objetivo principal del proyecto.
* **Mayor rendimiento (Throughput):** Aunque una sola instrucción tarda 3 ciclos en completarse, el sistema puede finalizar una instrucción en casi cada ciclo. Esto significa que procesa muchas más instrucciones en el mismo período de tiempo que la versión uniciclo.
* **Código más modular:** La separación de responsabilidades hace que el diseño sea más ordenado y fácil de mantener o mejorar en el futuro (por ejemplo, añadiendo lógica para manejar riesgos de datos o de control).

### **6. Conclusión del Trabajo**

El proyecto nos permitió aplicar de manera práctica los conceptos teóricos de la arquitectura de computadores, enfrentándonos a los desafíos reales que implica la segmentación de un procesador. La transición del modelo uniciclo a un pipeline de 3 etapas fue exitosa, resultando en un diseño funcional que demuestra una mejora significativa en el rendimiento. Las decisiones de diseño tomadas, especialmente en la gestión del flujo de datos y la actualización del PC, fueron cruciales para asegurar la correcta operación del procesador. Este trabajo sienta una base sólida para futuras optimizaciones, como la implementación de mecanismos de adelantamiento (*forwarding*) para resolver riesgos de datos.